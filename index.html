<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <link rel="stylesheet" href="style.css">
    <link rel="preload"
        href="https://fonts.googleapis.com/css2?family=Hanken+Grotesk:wght@100..900&family=Lato:wght@100;300;400;700;900&display=swap"
        as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link
            href="https://fonts.googleapis.com/css2?family=Hanken+Grotesk:wght@100..900&family=Lato:wght@100;300;400;700;900&display=swap"
            rel="stylesheet">
    </noscript>
    <title>Giacomo Garetto</title>
</head>

<body class="homepage">
    <div id="header">
        <a id="homeBtn" href="index.html">GIACOMO GARETTO</a>
        <button id="aboutBtn">ABOUT</button>
        <button id="closeAboutBtn">✕</button>
    </div>

    <div id="toggleRotation">
        <p>PAUSE</p>
    </div>

    <div id="scene"></div>

    <!-- Scheda informativa -->
    <div id="infoCard">
        <img id="projectPreview" src="" alt="Anteprima del progetto" style="display: none; max-width: 100%">
        <h2 id="projectTitle">Titolo Progetto</h2>
        <p id="projectDescription">Descrizione del progetto.</p>
        <div id="infoBottom">
            <p id="coordinates">Milano</p>
            <p id="projectDate">22-12-2022</p>
        </div>
    </div>

    <div id="aboutOverlay"></div>

    <div id="aboutText">
        <h2 class="aboutTitle">About me</h2>
        <p id="aboutMainText">Hi, I'm Giacomo, a graphic designer from Turin with a passion for everything visual. I
            love experimenting with new visual languages and i am always eager to learn something new. Photography
            fascinates me, and I enjoy getting hands-on, exploring how things work from the inside out. Creativity,
            curiosity, and a drive to innovate define my approach to design and beyond.</p>

        <div id="aboutColumns">
            <div class="aboutColumn">
                <h2 class="aboutTitle">Education</h2>
                <ul>
                    <li>Currently completing a Master's Degree in Communication Design at Politecnico di Milano</li>
                    <li>Bachelor's Degree in Communication Design at Politecnico di Torino</li>
                    <li>High School Diploma in Scientific Studies</li>
                </ul>
            </div>
            <div class="aboutColumn">
                <h2 class="aboutTitle">Work Experience</h2>
                <ul>
                    <li>Freelance Junior Graphic Designer at Noodles Communication Srl – 2 months</li>
                    <li>Internship at Noodles Communication Srl – 2 months</li>
                    <li>Freelance 3D Artist for Small Giants Srl</li>
                </ul>
            </div>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>

        // Quando clicco su ABOUT, attivo la classe
        document.getElementById('aboutBtn').addEventListener('click', function () {
            document.body.classList.add('about-active');
        });

        // Quando clicco su GIACOMO GARETTO (homeBtn), torno allo stato iniziale
        document.getElementById('homeBtn').addEventListener('click', function () {
            document.body.classList.remove('about-active');
        });

        // Aggiunge l'evento al pulsante ABOUT per aprire l'about
        document.getElementById('aboutBtn').addEventListener('click', function () {
            document.body.classList.add('about-active'); // Attiva la modalità About
        });

        // Aggiunge l'evento alla X per chiudere l'about
        document.getElementById('closeAboutBtn').addEventListener('click', function () {
            document.body.classList.remove('about-active'); // Disattiva la modalità About
        });


        let scene, camera, renderer, galaxy, raycaster, mouse;
        let rotatingSpeed = window.innerWidth <= 768 ? 0.00001 : 0.001;
        let rotating = true;
        let projectsMoving = true;
        let galaxyPositionY = 9;
        let isModelActive = false; // Stato iniziale: la sfera è visibile
        let modelVisible = false; // Stato per il click su mobile


        let centralSphere;
        let isCentralHovered = false;
        const defaultCentralScale = 1;
        const targetCentralScale = 4; // Imposta la scala desiderata per l'hover


        // Aggiungi le descrizioni ai dati dei progetti
        const projectsData = [
            { name: "Proj 1", projectName: "Digital Forest", info: "22/11/2025", hoverImage: "images/previews/data_preview.jpg", anteImg: "images/ante/data_ante.jpg", description: "The project analyzes 273 trail cam videos from Italian social platforms (2021-2024), exploring hashtags as tools of human categorization. The installation arranges videos chronologically with their hashtags, forming a growing network that reflects the evolving interplay between human perception and animal presence in a digital forest.", url: "project1.html" },
            { name: "Proj 2", projectName: "Falken's Room", info: "12/09/2022", hoverImage: "images/previews/falkens_preview.jpg", anteImg: "images/ante/falk_ante.jpg", description: "This thesis analyzes interactive installations through a practical case study, exploring their development, communication potential, and challenges. The study focuses on a 3D interactive installation inspired by 80s arcade games, designed and showcased at the Graphic Days 2022 festival.", url: "project2.html" },
            { name: "Proj 3", projectName: "VOTE", info: "25/06/2024", hoverImage: "images/previews/vote_preview.jpg", anteImg: "images/ante/vote_ante.jpg", description: "Vote is an interactive experience designed to actively engage students in a reflection on the value of voting and democratic representation. Developed within the Interaction Design Studio course at the Politecnico di Milano, the project addresses the growing disinterest in electoral participation, especially among young people.", url: "project3.html" },
            { name: "Proj 4", projectName: "Chronicles of Ink", info: "01/07/2024", hoverImage: "images/previews/chronicles_preview.jpg", anteImg: "images/ante/chron_ante.jpg", description: "The Chronicles of Ink is an Interactive Digital Narrative experience that explores social judgement and self-exploration through the metaphorical fantasy world of Talea. The project aims to raise awareness of the social double standard towards tattoos by examining how the perception of these art forms varies culturally and socially.", url: "project4.html" },
            { name: "Proj 5", projectName: "Beyondwaste", info: "27/02/2025", hoverImage: "images/previews/beyond_preview.jpg", anteImg: "images/ante/beyond_ante.jpg", description: "Beyondwaste is a presentation event designed by LATTER Studio for the innovative E-Trash bin concept. I contributed to the project by creating high-quality 3D visuals for the event's launch campaign. ", url: "project5.html" },
            { name: "Proj 6", projectName: "Salotto di Milano", info: "15/01/2024", hoverImage: "images/previews/salotto_preview.jpg", anteImg: "images/ante/salotto_ante.jpg", description: "The Salotto di Milano stands as an intersection of art, technology and culture. It is a journey that redefines how we all interact in the digital age, expanding the heart of Milano in the digital space.", url: "project6.html" },
        ];

        const rings = [];
        const projectsMeshes = [];
        const labels = [];
        const previewImages = [];

        let INTERSECTED = null;

        // Seleziona gli elementi della scheda informativa
        const infoCard = document.getElementById('infoCard');
        const projectTitle = document.getElementById('projectTitle');
        const projectDescription = document.getElementById('projectDescription');
        const projectDate = document.getElementById('projectDate')
        const projectPreview = document.getElementById('projectPreview');
        const aboutElement = document.getElementById('aboutText');

        const ringDistance = 6;

        // Carica il modello 3D
        const gltfLoader = new THREE.GLTFLoader();
        let model3D;
        gltfLoader.load('3D.glb', function (gltf) {
            model3D = gltf.scene;
            // Imposta la scala iniziale del modello più grande
            model3D.scale.set(25, 25, 25);
            model3D.visible = false;
            galaxy.add(model3D);
        });



        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('scene').appendChild(renderer.domElement);
            renderer.setPixelRatio(2);

            camera.position.z = 60;

            galaxy = new THREE.Object3D();
            galaxy.rotation.x = THREE.Math.degToRad(30);
            galaxy.rotation.z = THREE.Math.degToRad(10);

            scene.add(galaxy);

            createCentralSphere();
            createRingsAndProjects();
            addLighting();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            animate();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('wheel', onMouseWheel, false);
            document.addEventListener('click', onClick, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('touchstart', onTouchStart, false);
            document.addEventListener('touchmove', onTouchMove, false);
            window.addEventListener('resize', adjustGalaxyScale);
            window.addEventListener('load', adjustGalaxyScale);
            window.addEventListener('resize', adjustGalaxyPosition);
            window.addEventListener('load', adjustGalaxyPosition);
            // Ascolta la prima interazione dell'utente
            window.addEventListener('mousemove', activateUserInteraction);
            window.addEventListener('touchstart', activateUserInteraction);
        }

        window.addEventListener('resize', () => {
            if (!isRotationPaused) {
                rotatingSpeed = window.innerWidth <= 768 ? 0.00001 : 0.001;
            }
        });

        function activateUserInteraction() {
            userInteracted = true; // L'utente ha interagito, attiva l'hover
            window.removeEventListener('mousemove', activateUserInteraction);
            window.removeEventListener('touchstart', activateUserInteraction);
        }

        // Ascolta la prima interazione dell'utente
        window.addEventListener('mousemove', activateUserInteraction);
        window.addEventListener('touchstart', activateUserInteraction);


        function adjustGalaxyPosition() {
            if (window.innerWidth <= 768) {
                galaxyPositionY = 5; // Abbassa la posizione su mobile
            } else {
                galaxyPositionY = 9; // Posizione originale su desktop
            }

            // Applica la modifica immediatamente alla galassia se esiste
            if (galaxy) {
                galaxy.position.y = galaxyPositionY;
            }
        }




        function adjustGalaxyScale() {
            if (window.innerWidth <= 768) {
                galaxy.scale.set(0.8, 0.8, 0.8); // Riduce la scala al 70% su mobile
            } else {
                galaxy.scale.set(1, 1, 1); // Ripristina la scala su desktop
            }
        }

        // Crea la sfera centrale
        function createCentralSphere() {
            const sphereGeometry = new THREE.SphereGeometry(4, 25, 25);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffffff, shininess: 11 });
            // Salva la sfera in una variabile globale
            centralSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            galaxy.add(centralSphere);
        }


        // Crea gli anelli e i progetti
        function createRingsAndProjects() {
            const ringCount = projectsData.length;
            const projectCount = projectsData.length;
            const ringThickness = window.innerWidth <= 768 ? 0.08 : 0.04;


            for (let i = 0; i < ringCount; i++) {
                const ringGeometry = new THREE.TorusGeometry(10 + i * ringDistance, ringThickness, 10, 200);
                const ringMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x040404, shininess: 11, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);

                ring.rotation.x = Math.PI / 2;
                ring.userData = { angle: 0 };
                rings.push(ring);
                galaxy.add(ring);

                if (i < projectCount) {
                    createProject(projectsData[i], i);
                }
            }
        }

        function createProject(projectData, ringIndex) {
            const projectDimension = window.innerWidth <= 768 ? 2.0 : 1.5;

            const projectGeometry = new THREE.CircleGeometry(projectDimension, 64);
            const projectMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const projectMesh = new THREE.Mesh(projectGeometry, projectMaterial);

            projectMesh.userData = {
                ringIndex: ringIndex,
                angle: Math.random() * Math.PI * 2,
                hoverImage: projectData.hoverImage,
                anteImg: projectData.anteImg,
                description: projectData.description,
                name: projectData.name,
                projectName: projectData.projectName,
                info: projectData.info,
                url: projectData.url, // Associa l'URL del progetto
                originalMaterial: projectMaterial,
                outlineMaterial: new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }),
                isHovered: false
            };

            projectsMeshes.push(projectMesh);
            galaxy.add(projectMesh);

            const previewImage = createPreviewImage(projectData.hoverImage);
            previewImage.position.z = 2;
            previewImage.visible = false;
            previewImages.push(previewImage);
            galaxy.add(previewImage);
            const label = createLabel(projectData.name);
            labels.push(label);
            galaxy.add(label);
        }


        // Funzione aggiornata per gestire l'hover


        function createLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Aumenta la larghezza del canvas mantenendo l'altezza invariata
            canvas.width = 512;  // Aumentata da 512 a 800
            canvas.height = 128;

            // Imposta il font e le proprietà del testo
            if (window.innerWidth <= 768) {
                context.font = "bold 40px Hanken Grotesk";
            } else {
                context.font = "40px Hanken Grotesk";
            }

            // Posizione fissa per il testo dall'inizio del canvas
            const xPosition = 50;  // Distanza dal margine sinistro
            const yPosition = canvas.height / 2;

            // Imposta l'allineamento del testo
            context.textAlign = "left";
            context.textBaseline = "middle";

            // Disegna l'outline
            context.strokeStyle = 'black';
            context.lineWidth = 3;
            context.strokeText(text, xPosition, yPosition);

            // Disegna il testo principale
            context.fillStyle = 'white';
            context.fillText(text, xPosition, yPosition);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Adatta la scala della sprite alla nuova larghezza del canvas
            sprite.scale.set(20, 5, 1);  // Aumentata la x da 20 a 30
            return sprite;
        }

        function createPreviewImage(hoverImage) {
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(
                hoverImage,
                () => { console.log(`Image ${hoverImage} loaded successfully`); },
                undefined,
                (err) => { console.error(`Error loading image ${hoverImage}`, err); }
            );

            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                depthTest: false,
                transparent: true,  // Abilita la trasparenza
                opacity: 0          // Parti da opacity 0
            });

            const geometry = new THREE.CircleGeometry(1.5, 64);
            const mesh = new THREE.Mesh(geometry, material);

            // Imposta la scala a quella finale, ma l'oggetto sarà invisibile inizialmente
            mesh.scale.set(5, 5, 1);
            mesh.position.z = 2;
            mesh.renderOrder = 1;
            // Puoi anche impostare direttamente visible a false se lo preferisci
            mesh.visible = false;

            return mesh;
        }

        function animateOpacity(object, targetOpacity, duration, onCompleteCallback) {
            // Se stiamo facendo un fade in, assicuriamoci che l'oggetto sia visibile
            if (targetOpacity > 0) {
                object.visible = true;
            }
            new TWEEN.Tween({ opacity: object.material.opacity })
                .to({ opacity: targetOpacity }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(function (obj) {
                    object.material.opacity = obj.opacity;
                })
                .onComplete(function () {
                    // Se l'animazione porta a 0, rendi l'oggetto invisibile
                    if (targetOpacity === 0) {
                        object.visible = false;
                    }
                    if (onCompleteCallback) onCompleteCallback();
                })
                .start();
        }

        function updateProjects() {
            // Rendi il movimento dei progetti condizionale, ma l'orientamento costante
            projectsMeshes.forEach((projectMesh, index) => {
                if (projectsMoving) {
                    const ring = rings[projectMesh.userData.ringIndex];
                    const radius = 10 + projectMesh.userData.ringIndex * ringDistance;

                    projectMesh.userData.angle -= 0.005;
                    const angle = projectMesh.userData.angle;

                    projectMesh.position.set(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    );
                }

                // Mantieni i progetti orientati verso la camera indipendentemente dallo stato di rotazione
                projectMesh.lookAt(camera.position);

                const label = labels[index];
                label.position.set(
                    projectMesh.position.x,
                    projectMesh.position.y,
                    projectMesh.position.z
                );
                label.lookAt(camera.position);

                const previewImage = previewImages[index];
                previewImage.position.set(
                    projectMesh.position.x,
                    projectMesh.position.y,
                    projectMesh.position.z
                );
                previewImage.lookAt(camera.position);
            });
        }

        function addLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.75);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.65);
            pointLight.position.set(0, 0, 50);
            scene.add(pointLight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick(event) {
            if (isMobileDevice()) {
                // Su mobile, controlla prima se è stato cliccato il modello o la sfera centrale
                raycaster.setFromCamera(mouse, camera);
                const centralIntersects = raycaster.intersectObjects([centralSphere, model3D]);

                if (centralIntersects.length > 0) {
                    if (centralIntersects[0].object === centralSphere && !isModelActive && !isAnimating) {
                        // Click sulla sfera centrale
                        isAnimating = true;
                        showModel(() => {
                            isModelActive = true;
                            isAnimating = false;
                            // Avvia il timer di 15 secondi
                            modelTimer = setTimeout(() => {
                                if (!isAnimating) {
                                    isAnimating = true;
                                    showSphere(() => {
                                        isModelActive = false;
                                        isAnimating = false;
                                    });
                                }
                            }, 10000);
                        });
                    } else if (centralIntersects[0].object === model3D && isModelActive && !isAnimating) {
                        // Click sul modello 3D
                        if (modelTimer) {
                            clearTimeout(modelTimer);
                            modelTimer = null;
                        }
                        isAnimating = true;
                        showSphere(() => {
                            isModelActive = false;
                            isAnimating = false;
                        });
                    }
                } else {
                    // Controlla se è stato cliccato un progetto
                    const projectIntersects = raycaster.intersectObjects(projectsMeshes);
                    if (projectIntersects.length > 0) {
                        const clickedProject = projectIntersects[0].object;
                        window.location.href = clickedProject.userData.url;
                    }
                }
            } else {
                // Comportamento desktop esistente
                if (INTERSECTED) {
                    if (infoCard.style.display === 'block') {
                        infoCard.classList.add('expandCard');
                        const projectUrl = INTERSECTED.userData.url;
                        if (projectUrl) {
                            setTimeout(() => {
                                window.location.href = projectUrl;
                            }, 500);
                        }
                    }
                }
            }
        }

        function scaleProject(object, scale) {
            object.scale.set(scale, scale, scale);
        }

        // Funzione per mostrare la scheda informativa

        function showInfoCard(name, description, anteImg, info) {
            projectTitle.textContent = INTERSECTED.userData.projectName;;
            projectDescription.textContent = description;
            projectPreview.src = anteImg;
            projectDate.textContent = info;
            projectPreview.style.display = 'block';

            infoCard.classList.remove('hideCard', 'expandCard'); // Rimuovi eventuali classi precedenti
            infoCard.classList.add('showCard'); // Aggiungi la classe di entrata
            infoCard.style.display = 'block';
        }

        function hideInfoCard() {
            infoCard.classList.remove('showCard', 'expandCard');
            infoCard.classList.add('hideCard');

            setTimeout(() => {
                infoCard.style.display = 'none';
                // Riprendi la rotazione solo se il bottone era in modalità rotazione attiva
                if (!isRotationPaused) {
                    startRotation();
                    startProjectsMovement();
                }
            }, 100); // La durata deve corrispondere alla durata dell'animazione
        }

        function stopRotation() {
            new TWEEN.Tween({ speed: rotatingSpeed })
                .to({ speed: 0 }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(function (obj) {
                    rotatingSpeed = obj.speed;
                })
                .onComplete(function () {
                    rotating = false;
                })
                .start();
        }

        function startRotation() {
            const targetSpeed = window.innerWidth <= 768 ? 0.0001 : 0.001;  // Velocità dimezzata su mobile

            new TWEEN.Tween({ speed: 0 })
                .to({ speed: targetSpeed }, 1000)
                .easing(TWEEN.Easing.Quadratic.In)
                .onUpdate(function (obj) {
                    rotatingSpeed = obj.speed;
                    rotating = true;
                })
                .start();
        }

        function stopProjectsMovement() {
            projectsMoving = false;
        }

        function startProjectsMovement() {
            projectsMoving = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let scrollDelta = 0;

        function onMouseWheel(event) {
            scrollDelta += event.deltaY * 0.0002;
        }

        // Seleziona il bottone
        const toggleRotationButton = document.getElementById('toggleRotation');

        // Variabile per tracciare lo stato di pausa
        let isRotationPaused = false;

        // Aggiungi l'evento di click al bottone
        toggleRotationButton.addEventListener('click', () => {
            isRotationPaused = !isRotationPaused; // Inverti lo stato

            if (isRotationPaused) {
                toggleRotationButton.textContent = 'PLAY'; // Cambia il testo del bottone
                toggleRotationButton.classList.add("active");
                stopRotation(); // Chiama la funzione per fermare la rotazione
                stopProjectsMovement();
            } else {
                toggleRotationButton.textContent = 'PAUSE'; // Cambia il testo del bottone
                toggleRotationButton.classList.remove("active");
                startRotation(); // Chiama la funzione per riprendere la rotazione
                startProjectsMovement();
            }
        });

        function showModel(callback) {
            animateScale3D(centralSphere, 0, 300, () => {
                centralSphere.visible = false;
                model3D.visible = true;
                animateScale3D(model3D, 25, 300, callback);
            });
        }

        function showSphere(callback) {
            animateScale3D(model3D, 0, 300, () => {
                model3D.visible = false;
                centralSphere.visible = true;
                animateScale3D(centralSphere, 1, 300, callback);
            });
        }

        function animateScale3D(object, targetScale, duration, onComplete) {
            if (!object) return;

            new TWEEN.Tween({ scale: object.scale.x })
                .to({ scale: targetScale }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(function (obj) {
                    object.scale.set(obj.scale, obj.scale, obj.scale);
                })
                .onComplete(() => {
                    if (onComplete) onComplete();
                })
                .start();
        }




        function animateScale(object, targetScale, duration, onCompleteCallback) {
            // Se l'oggetto è già alla scala target, esegui il callback e esci
            if (Math.abs(object.scale.x - targetScale) < 0.01) {
                if (onCompleteCallback) onCompleteCallback();
                return;
            }
            // Se esiste già un tween che punta allo stesso target, non ricominciare
            if (object.userData.scaleTween && object.userData.currentTarget === targetScale) {
                return;
            }
            // Ferma eventuali tween in corso
            if (object.userData.scaleTween) {
                object.userData.scaleTween.stop();
            }
            // Salva il target corrente
            object.userData.currentTarget = targetScale;
            const currentScale = object.scale.x;
            object.userData.scaleTween = new TWEEN.Tween({ scale: currentScale })
                .to({ scale: targetScale }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(function (obj) {
                    object.scale.set(obj.scale, obj.scale, obj.scale);
                })
                .onComplete(function () {
                    object.userData.scaleTween = null;
                    object.userData.currentTarget = targetScale;
                    if (onCompleteCallback) onCompleteCallback();
                })
                .start();
        }

        // Variabili per il touch scrolling
        let touchStartX = 0;
        let touchStartY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;

        // Funzione per iniziare il touch
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        }

        // Funzione per gestire il movimento del touch
        function onTouchMove(event) {
            if (event.touches.length === 1) {
                let touchMoveX = event.touches[0].clientX;
                let touchMoveY = event.touches[0].clientY;

                // Calcola il movimento rispetto alla posizione iniziale
                touchDeltaX = (touchMoveX - touchStartX) * 0.006; // Scala per maggiore sensibilità
                touchDeltaY = (touchMoveY - touchStartY) * 0.006;

                // Aggiorna la posizione iniziale per il prossimo movimento
                touchStartX = touchMoveX;
                touchStartY = touchMoveY;
            }
        }

        let userInteracted = false; // Flag per controllare se l'utente ha interagito
        let isAnimating = false;
        let modelTimer = null;

        function isMobileDevice() {
            return (window.innerWidth <= 768) || ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }


        // Modifica la funzione `animate` per rispettare lo stato di `rotating`
        function animate() {
            requestAnimationFrame(animate);

            // Rotazione e aggiornamenti della galassia
            galaxy.rotation.y += rotating ? rotatingSpeed : 0;
            galaxy.rotation.y += scrollDelta;
            galaxy.rotation.y += touchDeltaX;
            scrollDelta *= 0.9;
            touchDeltaX *= 0.9;
            touchDeltaY *= 0.9;

            TWEEN.update();
            updateProjects();
            galaxy.position.y = galaxyPositionY;

            // Controllo del raycaster per l'hover sulla sfera centrale (solo su desktop)
            if (!isMobileDevice()) {
                if (!document.body.classList.contains('about-active') && userInteracted) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects([centralSphere, model3D]);

                    if (intersects.length > 0) {
                        // Se interseca la sfera e il modello non è attivo
                        if (intersects[0].object === centralSphere && !isModelActive && !isAnimating) {
                            isAnimating = true;
                            showModel(() => {
                                isModelActive = true;
                                isAnimating = false;
                                // Avvia il timer di 15 secondi
                                modelTimer = setTimeout(() => {
                                    if (!isAnimating) {
                                        isAnimating = true;
                                        showSphere(() => {
                                            isModelActive = false;
                                            isAnimating = false;
                                        });
                                    }
                                }, 10000);
                            });
                        }
                        // Se interseca il modello 3D e il modello è attivo
                        else if (intersects[0].object === model3D && isModelActive && !isAnimating) {
                            // Cancella il timer esistente
                            if (modelTimer) {
                                clearTimeout(modelTimer);
                                modelTimer = null;
                            }
                            isAnimating = true;
                            showSphere(() => {
                                isModelActive = false;
                                isAnimating = false;
                            });
                        }
                    }
                }

                // Controllo intersezioni per i progetti (solo su desktop)
                if (!document.body.classList.contains('about-active') && userInteracted) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(projectsMeshes);
                    if (intersects.length > 0) {
                        const intersected = intersects[0].object;
                        if (INTERSECTED !== intersected) {
                            if (INTERSECTED) {
                                labels[projectsMeshes.indexOf(INTERSECTED)].visible = true;
                                animateOpacity(previewImages[projectsMeshes.indexOf(INTERSECTED)], 0, 150);
                                animateScale(INTERSECTED, 1, 150);
                            }
                            INTERSECTED = intersected;
                            labels[projectsMeshes.indexOf(INTERSECTED)].visible = false;
                            animateScale(INTERSECTED, 5, 150, () => {
                                animateOpacity(previewImages[projectsMeshes.indexOf(INTERSECTED)], 1, 150);
                            });
                            showInfoCard(
                                INTERSECTED.userData.name,
                                INTERSECTED.userData.description,
                                INTERSECTED.userData.anteImg,
                                INTERSECTED.userData.info
                            );
                            stopRotation();
                            stopProjectsMovement();
                        }
                    } else if (INTERSECTED) {
                        labels[projectsMeshes.indexOf(INTERSECTED)].visible = true;
                        animateOpacity(previewImages[projectsMeshes.indexOf(INTERSECTED)], 0, 150);
                        animateScale(INTERSECTED, 1, 150);
                        INTERSECTED = null;
                        hideInfoCard();
                    }
                }
            }

            renderer.render(scene, camera);
        }




        init();
    </script>

    <script>
        function updateThemeColor(color) {
            let metaThemeColor = document.querySelector("meta[name=theme-color]");
            if (metaThemeColor) {
                metaThemeColor.setAttribute("content", color);
            } else {
                let meta = document.createElement("meta");
                meta.name = "theme-color";
                meta.content = color;
                document.head.appendChild(meta);
            }
        }

        // Imposta il colore iniziale in base alla pagina
        if (document.body.classList.contains("inverted-theme")) {
            updateThemeColor("#FFFFFF"); // Bianco per il tema invertito
        } else {
            updateThemeColor("#000000"); // Nero per il tema normale
        }

        // Aggiorna dinamicamente quando cambia il tema
        document.addEventListener("DOMContentLoaded", function () {
            let observer = new MutationObserver(() => {
                if (document.body.classList.contains("inverted-theme")) {
                    updateThemeColor("#FFFFFF"); // Bianco per tema chiaro
                } else {
                    updateThemeColor("#000000"); // Nero per tema scuro
                }
            });

            observer.observe(document.body, { attributes: true, attributeFilter: ["class"] });
        });
    </script>

</body>

</html>
